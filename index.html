<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webgl demo</title>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
        }

        body {
            background-color: black;
        }

        body::-webkit-scrollbar {
            display: none;
        }
        
        /* make the canvas fill its container */
        #c {
            width: 100vw;
            height: 100vh;
            display: block;
            z-index: 2;
        }

        #bg {
            display: flex;
            justify-content: center;
            align-items: center;

            position: absolute;
            left: 50%;
            top: 50%;
            width: 100%;
            height: 100%;
            transform: translate(-50%, -50%);
            z-index: -1;
        }
    </style>
    <audio loop src="./resources/Drums.wav"></audio>
</head>
<body>
    <img id="bg" src="./resources/Vignette.png"></img>
    <canvas id="c"></canvas>
    <script id="vertex-shader" type="x-shader/x-vertex">
        // an attribute will recieve data from a buffer
        attribute vec4 a_position;
        attribute vec2 a_texcoord;
        attribute vec3 a_normal;

        uniform vec3 u_lightWorldPosition;
        
        uniform mat4 u_world;
        uniform mat4 u_worldViewProjection;
        uniform mat4 u_worldInverseTranspose;

        varying vec2 v_texcoord;
        varying vec3 v_normal;
        varying vec3 v_surfaceToLight;
        
        void main() {
            gl_Position = u_worldViewProjection * a_position;

            v_texcoord = a_texcoord;
            v_normal = mat3(u_worldInverseTranspose) * a_normal;

            vec3 surfaceWorldPosition = (u_world * a_position).xyz;
            v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
        }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">
        // fragment shaders don't have a default precision so we need
        // to pick one. mediump is a good default
        precision mediump float;
        
        varying vec2 v_texcoord;
        varying vec3 v_normal;
        varying vec3 v_surfaceToLight;

        uniform sampler2D u_texture;
        
        void main() {
            vec3 normal = normalize(v_normal);
            vec3 surfaceToLightDirection = normalize(v_surfaceToLight);

            float light = dot(normal, surfaceToLightDirection);

            gl_FragColor = texture2D(u_texture, v_texcoord);
            gl_FragColor.rgb *= (light * 0.4) + 0.6;
        }
    </script>
    <script>
        // --------------- Engine Helpers ----------------

        // attributes
        var vertexLocation;
        var texcoordLocation;
        var normalLocation;
        // uniforms
        var worldViewProjectionLocation;
        var worldInverseTransposeLocation;
        var textureLocation;
        var lightWorldPositionLocation;
        var worldLocation;

        const modelList = [];
        const entityList = [];

        // Create texture
        function createTexture(gl, pathToTexture) {
            function isPowerOf2(value) {
                return (value & (value - 1)) == 0;
            }

            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                          new Uint8Array([0, 0, 255, 255]));

            var image = new Image();
            image.src = pathToTexture;
            image.addEventListener('load', function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else {
                    gl.texParameter(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameter(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameter(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
            });
            return texture;
        }

        function createGLBuffer(gl, buffer) {
            var glBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer), gl.STATIC_DRAW);
            return glBuffer;
        }

        // Entities
        function createEntity(name, modelID, position, rotation, scale) {
            this["name"] = name;
            this["modelID"] = modelID;
            this["position"] = position;
            this["rotation"] = rotation;
            this["scale"] = scale;
        }

        function drawEntity(entity, viewProjectionMatrix, gl) {
            useModel(gl, modelList[entity.modelID]);
            var matrix = m4.translation(entity.position[0], entity.position[1], entity.position[2]);
            matrix = m4.yRotate(matrix, entity.rotation[1]);
            matrix = m4.xRotate(matrix, entity.rotation[0]);
            matrix = m4.zRotate(matrix, entity.rotation[2]);
            matrix = m4.scale(matrix, entity.scale[0], entity.scale[1], entity.scale[2]);
            var projectedMatrix = m4.multiply(viewProjectionMatrix, matrix);

            var worldMatrix = matrix;
            worldInverseTranspose = m4.inverse(worldMatrix);
            worldInverseTranspose = m4.transpose(worldMatrix);

            // lighting
            gl.uniformMatrix4fv(worldLocation, false, worldMatrix);
            gl.uniformMatrix4fv(worldInverseTransposeLocation, false, worldInverseTranspose);
            gl.uniform3fv(lightWorldPositionLocation, [0, 500, 0]);

            gl.uniformMatrix4fv(worldViewProjectionLocation, false, projectedMatrix);
            gl.uniform1i(textureLocation, 0);
            gl.drawArrays(gl.TRIANGLES, 0, modelList[entity.modelID].vertexCount);
        }

        // Models
        function createModel(name, vertices, texCoords, normals, texturePath, gl) {
            this["name"] = name;
            this["vertexBuffer"] = createGLBuffer(gl, vertices);
            this["texCoordsBuffer"] = createGLBuffer(gl, texCoords);
            this["normalBuffer"] = createGLBuffer(gl, normals);
            this["texture"] = createTexture(gl, texturePath);
            this["vertexCount"] = vertices.length / 3;
        }

        function useModel(gl, model) {
            gl.bindTexture(gl.TEXTURE_2D, model.texture);

            gl.enableVertexAttribArray(vertexLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.vertexBuffer);
            gl.vertexAttribPointer(vertexLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(texcoordLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.texCoordsBuffer);
            gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(normalLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
            gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
        }

        function cameraMove(position, rotation, projectionMatrix) {
            var cameraMatrix = m4.yRotation(0);
            cameraMatrix = m4.translate(cameraMatrix, position[0], position[1], position[2]);
            cameraMatrix = m4.zRotate(cameraMatrix, rotation[2]);
            cameraMatrix = m4.yRotate(cameraMatrix, rotation[1]);
            cameraMatrix = m4.xRotate(cameraMatrix, rotation[0]);
            return cameraMatrix;
        }

        function createShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {
                return shader;
            }
            
            //error
            console.log(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }
        
        function createProgram(gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) {
                return program;
            }
            
            //error
            console.log(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        function glInitialization(gl) {
        }
        
        async function main() {
            const canvas = document.querySelector("#c");
            const gl = canvas.getContext("webgl", { depth: true });
            if (!gl) {
                console.log("No webgl :(");
                return;
            }


            // -------------- Set up audio player --------------
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            const audioContext = new AudioContext();

            // background sounds
            const drumsFile = document.querySelector("audio");
            const drums = audioContext.createMediaElementSource(drumsFile);
            drums.loop = true;

            const osc1 = audioContext.createOscillator();
            osc1.type = "square"; // sin, square, triangle, sawtooth
            osc1.frequency.setValueAtTime(note.F(3), audioContext.currentTime);
            const osc2= audioContext.createOscillator();
            osc2.type = "square"; // sin, square, triangle, sawtooth
            osc2.frequency.setValueAtTime(note.A(3), audioContext.currentTime);
            const osc3 = audioContext.createOscillator();
            osc3.type = "square"; // sin, square, triangle, sawtooth
            osc3.frequency.setValueAtTime(note.C(4), audioContext.currentTime);
            const osc4 = audioContext.createOscillator();
            osc4.type = "square"; // sin, square, triangle, sawtooth
            osc4.frequency.setValueAtTime(note.E(4), audioContext.currentTime);
            const osc5 = audioContext.createOscillator();
            osc5.type = "sine"; // sine, square, triangle, sawtooth
            osc5.frequency.setValueAtTime(note.F(2), audioContext.currentTime);

            function changeOscFreq(freq) {
                osc1.frequency.setValueAtTime(freq, audioContext.currentTime);
                osc2.frequency.setValueAtTime(freq * (note.A(3) / note.F(3)), audioContext.currentTime);
                osc3.frequency.setValueAtTime(freq * (note.C(4) / note.F(3)), audioContext.currentTime);
                osc4.frequency.setValueAtTime(freq * (note.E(4) / note.F(3)), audioContext.currentTime);
                osc5.frequency.setValueAtTime(freq * (note.F(2) / note.F(3)), audioContext.currentTime);
            }

            const gain = new GainNode(audioContext);
            gain.gain.setValueAtTime(0.2, audioContext.currentTime);

            const dGain = new GainNode(audioContext);
            dGain.gain.setValueAtTime(0.3, audioContext.currentTime);

            const gain2 = new GainNode(audioContext);
            gain2.gain.setValueAtTime(1, audioContext.currentTime);
            
            const filter = new BiquadFilterNode(audioContext);
            filter.type = "lowpass";
            filter.frequency = 440;
            filter.Q = 0.3;

            function createImpulseResponse(duration, decay, reverse) {
                var sampleRate = audioContext.sampleRate;
                var length = sampleRate * duration;
                var impulse = audioContext.createBuffer(2, length, sampleRate);
                var impulseL = impulse.getChannelData(0);
                var impulseR = impulse.getChannelData(1);

                if (!decay)
                    decay = 2.0;
                for (var i = 0; i < length; i++){
                  var n = reverse ? length - i : i;
                  impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
                  impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
                }
                return impulse;
            }

            const convolver = audioContext.createConvolver();
            convolver.buffer = createImpulseResponse(1, 4, false);

            const listener = audioContext.listener;

            function setPannerOrientation(x, y, z) {
                if (panner.orientationX) {
                    panner.orientationX.setValueAtTime(x, audioContext.currentTime);
                    panner.orientationY.setValueAtTime(y, audioContext.currentTime);
                    panner.orientationZ.setValueAtTime(z, audioContext.currentTime);
                } else {
                    panner.setOrientation(x, y, z);
                }
            }

            function setPannerPosition(x, y, z) {
                if (panner.positionX) {
                    panner.positionX.setValueAtTime(x, audioContext.currentTime);
                    panner.positionY.setValueAtTime(y, audioContext.currentTime);
                    panner.positionZ.setValueAtTime(z, audioContext.currentTime);
                } else {
                    panner.setPosition(x, y, z);
                }
            }

            function setListenerOrientation(fx, fy, fz, ux, uy, uz) {
                if (listener.forwardX) {
                    listener.forwardX.setValueAtTime(fx, audioContext.currentTime);
                    listener.forwardY.setValueAtTime(fy, audioContext.currentTime);
                    listener.forwardZ.setValueAtTime(fz, audioContext.currentTime);
                    listener.upX.setValueAtTime(ux, audioContext.currentTime);
                    listener.upY.setValueAtTime(uy, audioContext.currentTime);
                    listener.upZ.setValueAtTime(uz, audioContext.currentTime);
                } else {
                    listener.setOrientation(fx, fy, fz, ux, uy, uz);
                }
            }

            function setListenerPosition(x, y, z) {
                if (listener.positionX) {
                    listener.positionX.setValueAtTime(x, audioContext.currentTime);
                    listener.positionY.setValueAtTime(y, audioContext.currentTime);
                    listener.positionZ.setValueAtTime(z, audioContext.currentTime);
                } else {
                    listener.setPosition(x, y, z);
                }
            }

            const panner = audioContext.createPanner();
            panner.panningModel = "HRTF";
            panner.distanceModel = "inverse";
            panner.refDistance = 100;
            panner.maxDistance = 10000;
            panner.rolloffFactor = 1;
            panner.coreInnerAngle = 360;
            panner.coneOuterAngle = 0;
            panner.coneOuterGain = 0;
            setPannerOrientation(1, 0, 0);
            setPannerPosition(0, 0, 0);

            setListenerOrientation(0, 0, -1, 0, 1, 0);
            setListenerPosition(0, 0, 800);

            osc1.connect(gain);
            osc2.connect(gain);
            osc3.connect(gain);
            osc4.connect(gain);
            osc5.connect(gain);
            gain.connect(filter).connect(panner).connect(convolver).connect(gain2);
            
            drums.connect(dGain).connect(gain2);

            gain2.connect(audioContext.destination);

            osc1.start(audioContext.currentTime);
            osc2.start(audioContext.currentTime);
            osc3.start(audioContext.currentTime);
            osc4.start(audioContext.currentTime);
            osc5.start(audioContext.currentTime);

            // --------------------------------------------------

            // ------------------ WebGL init --------------------

            gl.enable(gl.CULL_FACE);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            const vertexShaderSource = document.querySelector("#vertex-shader").text;
            const fragmentShaderSource = document.querySelector("#fragment-shader").text;
            
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            program = createProgram(gl, vertexShader, fragmentShader);
            
            // Set uniform locations
            vertexLocation = gl.getAttribLocation(program, "a_position");
            texcoordLocation = gl.getAttribLocation(program, "a_texcoord");
            normalLocation = gl.getAttribLocation(program, "a_normal");

            worldViewProjectionLocation = gl.getUniformLocation(program, "u_worldViewProjection");
            worldInverseTransposeLocation = gl.getUniformLocation(program, "u_worldInverseTranspose");
            textureLocation = gl.getUniformLocation(program, "u_texture");
            lightWorldPositionLocation = gl.getUniformLocation(program, "u_lightWorldPosition");
            worldLocation = gl.getUniformLocation(program, "u_world");

            // Input Listeners
            canvas.addEventListener("click", onMouseDown);
            document.addEventListener("wheel", updateScrollWheel, {passive: false});
            document.addEventListener("keydown", keypress);
            document.addEventListener("pointerlockchange", lockChangeAlert);

            function lockChangeAlert() {
                if (document.pointerLockElement === canvas)
                    document.addEventListener("mousemove", updateMousePosition);
                else
                    document.removeEventListener("mousemove", updateMousePosition);
            }

            // --------------------------------------------------

            // -------------- Handle Inputs --------------
            function updateMousePosition(e) {
                // filter
                eqFrequency += e.movementX * 2;
                
                if (eqFrequency <= note.F(4)) {
                    eqFrequency = note.F(4);
                    spacingSpeed = 0.0;
                }
                else if (eqFrequency >= 10000)
                    eqFrequency = 10000;
                else
                    spacingSpeed += e.movementX * 0.001;

                // pitch
                oscFrequency -= e.movementY * 0.1;

                if (oscFrequency <= note.F(2))
                    oscFrequency = note.F(2);
                else if (oscFrequency >= note.F(5))
                    oscFrequency = note.F(5);
                else
                    fAngleRadians += e.movementY * 0.001;

                filter.frequency.setValueAtTime(eqFrequency, audioContext.currentTime);
                dGain.gain.value = 0.3 + (eqFrequency - note.F(4)) * 0.00001;
                changeOscFreq(oscFrequency);
            }

            async function captureCursor() {
                await canvas.requestPointerLock({ unadjustedMovement: false });
            }

            function onMouseDown(e) {
                if (document.pointerLockElement) {
                    if (e.button === 0) {
                        if (drumsFile.paused) {
                            drumsFile.play();
                        } else {
                            drumsFile.pause();
                        }
                    } else if (e.button === 2) {
                        //reset
                        camPosX = 0;
                        camPosY = 800;
                        instrRotationRadians = 0.0;
                        cameraLookAtX = 0.0;
                        cameraLookAtY = 0.0;
                        fAngleRadians = 0.0;
                        eqFrequency = note.F(4);
                        oscFrequency = note.F(3);
                        spacingSpeed = 0;
                        filter.frequency.setValueAtTime(eqFrequency, audioContext.currentTime);
                        dGain.gain.value = 0.3 + (eqFrequency - note.F(4)) * 0.00001;
                        changeOscFreq(oscFrequency);
                        drumsFile.pause();
                    }
                } else {
                    captureCursor();
                    if (audioContext.state === "suspended")
                        audioContext.resume();
                }
            }

            function updateScrollWheel(e) {
                if (e.ctrlKey) {
                    e.preventDefault();
                    tmpX = camPosX + Math.sin(cameraLookAtX) * 5 * e.deltaY;
                    tmpY = camPosY + Math.cos(cameraLookAtX) * 5 * e.deltaY;

                    if (tmpX > 4900)
                        tmpX = 4900;
                    else if (tmpX < -4900)
                        tmpX = -4900;
                    if (tmpY > 4900)
                        tmpY = 4900;
                    else if (tmpY < -4900)
                        tmpY = -4900;

                    camPosX = tmpX;
                    camPosY = tmpY;
                }
                else {
                    var tmp = cameraLookAtY;
                    tmp += 0.001 * e.deltaY;
                    if (tmp < -30 * Math.PI / 180)
                        tmp = -30 * Math.PI / 180;
                    else if (tmp > 60 * Math.PI / 180)
                        tmp = 60 * Math.PI / 180;
                    cameraLookAtY = tmp;

                    tmp = cameraLookAtX;
                    tmp += 0.001 * e.deltaX;
                    cameraLookAtX = tmp;
                }
            }

            function keypress(e) {
                if (e.key === 'p') {
                    if (audioContext.state === "suspended")
                        audioContext.resume();

                    if (!isPlaying) {
                        gain2.gain.linearRampToValueAtTime(1,
                            audioContext.currentTime + 0.2);
                        isPlaying = true;
                    } else {
                        gain2.gain.linearRampToValueAtTime(0.0001,
                            audioContext.currentTime + 0.2);
                        isPlaying = false;
                    }
                }
            }

            // --------------------------------------------------

            // Create model list
            const cube_m = await loadModel("./resources/cube.obj");
            const f_m = await loadModel("./resources/f.obj");
            const wall_m = await loadModel("./resources/forest-wall.obj");
            const chair_m = await loadModel("./resources/chair.obj");

            modelList.push(new createModel("f", f_m.position, f_m.texcoord, f_m.normal, "./resources/f-texture.png", gl));
            modelList.push(new createModel("cube", cube_m.position, cube_m.texcoord, cube_m.normal, "./resources/noodles.jpg", gl));
            modelList.push(new createModel("wall", wall_m.position, wall_m.texcoord, wall_m.normal, "./resources/Forest.png", gl));
            modelList.push(new createModel("chair", chair_m.position, chair_m.texcoord, chair_m.normal, "./resources/chair.png", gl));

            // Fs
            const numFs = 5;
            for (var i = 0; i < numFs; ++i) {
                entityList.push(new createEntity("f"+i, 0, [0, 0, 0], [0, deg2Rad(-90), 0], [20, 20, 20]));
            }

            cube_id = entityList.length;
            entityList.push(new createEntity("center cube", 1, [0, 200, 0], [1, 0, 0], [50, 50, 50]));

            // static things
            floor_id = entityList.length;
            entityList.push(new createEntity("floor", 1, [0, -400, 0], [0, 0, 0], [5200, 1, 5200]));
            entityList.push(new createEntity("floor2", 1, [15000, -400, 0], [0, 0, 0], [5000, 1, 5000]));
            entityList.push(new createEntity("floor3", 1, [-15000, -400, 0], [0, 0, 0], [5000, 1, 5000]));
            entityList.push(new createEntity("wall1", 2, [5100, -400, 0], [0,deg2Rad(90),0], [1000, 1000, 1000]));
            entityList.push(new createEntity("wall2", 2, [-5100, -400, 0], [0,deg2Rad(90),0], [1000, 1000, 1000]));
            entityList.push(new createEntity("wall3", 2, [10000, -400, 0], [0,deg2Rad(90),0], [1000, 1000, 1000]));
            entityList.push(new createEntity("wall4", 2, [-10000, -400, 0], [0,deg2Rad(90),0], [1000, 1000, 1000]));

            entityList.push(new createEntity("chair", 3, [-2000, 100, -500], [0,deg2Rad(-135),0], [50, 50, 50]));
            entityList.push(new createEntity("chair", 3, [-1000, 100, 400], [0,deg2Rad(-90),0], [50, 50, 50]));
            entityList.push(new createEntity("chair", 3, [500, 100, 1000], [0,deg2Rad(0),0], [50, 50, 50]));
            
            // -------------- Main Render Loop --------------
            
            function render(now) {
                resizeCanvasToDisplaySize(gl.canvas);

                // Projection matrix
                var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                var zNear = 50;
                var zFar = 50000;
                var fieldOfViewInRadians = 90 * Math.PI / 180;
                var projectionMatrix = m4.perspective(fieldOfViewInRadians, aspect, zNear, zFar);

                // convert the time to seconds
                now *= 0.001;
                var deltaTime = now - then;
                then = now;

                // update camera
                cameraMatrix = cameraMove(
                    [camPosX, 100, camPosY], //position
                    [cameraLookAtY, cameraLookAtX, 0], //rotation
                );

                // listener
                setListenerPosition(camPosX, 0, camPosY);
                setListenerOrientation(
                    -cameraMatrix[8], -cameraMatrix[9], -cameraMatrix[10], // -forward vector
                    cameraMatrix[4], cameraMatrix[5], cameraMatrix[6]      // up vector
                );

                const viewMatrix = m4.inverse(cameraMatrix);
                const viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

                // Update!
                instrRotationRadians = deltaTime * spacingSpeed * 1.0;

                // Fs
                for (var i = 0; i < numFs; ++i) {
                    entityList[i].rotation[1] += instrRotationRadians;
                    entityList[i].rotation[0] = fAngleRadians;

                    var angle = (i * Math.PI * 2 / numFs) - entityList[i].rotation[1];
                    var x = Math.cos(angle) * 100 * (1.25 + spacingSpeed);
                    var y = Math.sin(angle) * 100 * (1.25 + spacingSpeed);

                    entityList[i].position = [x, 0, y];
                    const scale = 20 + (2 * spacingSpeed);
                    entityList[i].scale = [scale, scale, scale];
                }
                entityList[cube_id].rotation[1] += instrRotationRadians;
                const scale = 50 + (10 * spacingSpeed);
                entityList[cube_id].scale = [scale, scale, scale];

                // draw calls
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.useProgram(program);

                for (var i = 0; i < entityList.length; ++i)
                    drawEntity(entityList[i], viewProjectionMatrix, gl);
                
                // Loop
                requestAnimationFrame(render);
            }

            async function loadModel(path) {
                const response = await fetch (path);
                const text = await response.text();
                return parseObj(text);
            }

            function parseObj(text) {
                // fill in 0th data since indices are base 1
                const objPositions = [[0, 0, 0]];
                const objTexcoords = [[0, 0]];
                const objNormals = [[0, 0, 0]];

                const objVertexData = [
                    objPositions,
                    objTexcoords,
                    objNormals,
                ];

                let webglVertexData = [
                    [], // positions
                    [], // texcoords
                    [], // normals
                ];

                function addVertex(vert) {
                    const ptn = vert.split('/');
                    ptn.forEach((objIndexStr, i) => {
                        if (!objIndexStr) return;
                        const objIndex = parseInt(objIndexStr);
                        const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
                        webglVertexData[i].push(...objVertexData[i][index]);
                    });
                }

                const keywords = {
                    v(parts) {
                        objPositions.push(parts.map(parseFloat));
                    },
                    vn(parts) {
                        objNormals.push(parts.map(parseFloat));
                    },
                    vt(parts) {
                        objTexcoords.push(parts.map(parseFloat));
                    },
                    f(parts) {
                        const numTriangles = parts.length - 2;
                        for (let tri = 0; tri < numTriangles; ++tri) {
                            addVertex(parts[0]);
                            addVertex(parts[tri + 1]);
                            addVertex(parts[tri + 2]);
                        }
                    },
                };

                const keywordRE = /(\w*)(?: )*(.*)/;
                const lines = text.split('\n');

                for (let lineNo = 0; lineNo < lines.length; ++lineNo) {
                    const line = lines[lineNo].trim();
                    if (line === '' || line.startsWith('#')) continue;

                    const m = keywordRE.exec(line);
                    if (!m) continue;

                    const [, keyword, unparsedArgs] = m;
                    const parts = line.split(/\s+/).slice(1);
                    const handler = keywords[keyword];
                    if (!handler) {
                        console.warn('unhandled keyword', keyword, 'at line', lineNo + 1);
                        continue;
                    }
                    handler(parts, unparsedArgs);
                }

                //reverse texcoords
                for (let i = 1; i < webglVertexData[1].length; i += 2) {
                    webglVertexData[1][i] = 1 - webglVertexData[1][i];
                }

                return {
                    position: webglVertexData[0],
                    texcoord: webglVertexData[1],
                    normal: webglVertexData[2],
                };
            }
            
            
            // -------------- Resize Window Code --------------
            
            const canvasToDisplaySizeMap = new Map([[canvas, [300, 150]]]);
                    
            function onResize(entries) {
                for (const entry of entries) {
                    let width;
                    let height;
                    let dpr = window.devicePixelRatio;
                    if (entry.devicePixelContentBoxSize) {
                        // NOTE: Only this path gives the correct answer
                        // The other 2 paths are an imperfect fallback
                        // for browsers that don't provide anyway to do this
                        width = entry.devicePixelContentBoxSize[0].inlineSize;
                        height = entry.devicePixelContentBoxSize[0].blockSize;
                        dpr = 1; // it's already in width and height
                    } else if (entry.contentBoxSize) {
                        if (entry.contentBoxSize[0]) {
                            width = entry.contentBoxSize[0].inlineSize;
                            height = entry.contentBoxSize[0].blockSize;
                        } else {
                            // legacy
                            width = entry.contentBoxSize.inlineSize;
                            height = entry.contentBoxSize.blockSize;
                        }
                    } else {
                        // legacy
                        width = entry.contentRect.width;
                        height = entry.contentRect.height;
                    }
                    const displayWidth = Math.round(width * dpr);
                    const displayHeight = Math.round(height * dpr);
                    canvasToDisplaySizeMap.set(entry.target, [displayWidth, displayHeight]);
                }
            }
            
            const resizeObserver = new ResizeObserver(onResize);
            resizeObserver.observe(canvas, {box: 'content-box'});
            
            function resizeCanvasToDisplaySize(canvas) {
                // Get the size the browser is displaying the canvas in device pixels.
                const [displayWidth, displayHeight] = canvasToDisplaySizeMap.get(canvas);
                
                // Check if the canvas is not the same size.
                const needResize = canvas.width  !== displayWidth ||
                                canvas.height !== displayHeight;
                
                if (needResize) {
                    // Make the canvas the same size
                    canvas.width  = displayWidth;
                    canvas.height = displayHeight;
                }
                
                return needResize;
            }
            
            requestAnimationFrame(render);
        }

        window.onload = main;

        var note = {
            allNotes: function() {
                return [
                    16.35, 32.70, 65.41, 130.81, 261.63, 523.25, 1046.50, 2093.00, 4186.01,
                    17.32, 34.65, 69.30, 138.59, 277.18, 554.37, 1108.73, 2217.46, 4434.92,
                    18.35, 36.71, 73.42, 146.83, 293.66, 587.33, 1174.66, 2349.32, 4698.63,
                    19.45, 38.89, 77.78, 155.56, 311.13, 622.25, 1244.51, 2489.02, 4978.03,
                    20.60, 41.20, 82.41, 164.81, 329.63, 659.25, 1318.51, 2637.02, 5274.04,
                    21.83, 43.65, 87.31, 174.61, 349.23, 698.46, 1396.91, 2793.83, 5587.65,
                    23.12, 46.25, 92.50, 185.00, 369.99, 739.99, 1479.98, 2959.96, 5919.91,
                    24.50, 49.00, 98.00, 196.00, 392.00, 783.99, 1567.98, 3135.96, 6271.93,
                    25.96, 51.91, 103.83, 207.65, 415.30, 830.61, 1661.22, 3322.44, 6644.88,
                    27.50, 55.00, 110.00, 220.00, 440.00, 880.00, 1760.00, 3520.00, 7040.00,
                    29.14, 58.27, 116.54, 233.08, 466.16, 932.33, 1864.66, 3729.31, 7458.62,
                    30.87, 61.74, 123.47, 246.94, 493.88, 987.77, 1975.53, 3951.07, 7902.13,
                ];
            },

            C: function(octave, bs) { 
                bs = bs || 0;
                return note.allNotes()[(0 + bs) + octave];
            },
            D: function(octave, bs) { 
                bs = bs || 0;
                return note.allNotes()[(2 + bs) * 9 + octave];
            },
            E: function(octave, bs) { 
                bs = bs || 0;
                return note.allNotes()[(4 + bs) * 9 + octave];
            },
            F: function(octave, bs) { 
                bs = bs || 0;
                return note.allNotes()[(5 + bs) * 9 + octave];
            },
            G: function(octave, bs) { 
                bs = bs || 0;
                return note.allNotes()[(7 + bs) * 9 + octave];
            },
            A: function(octave, bs) { 
                bs = bs || 0;
                return note.allNotes()[(9 + bs) * 9 + octave];
            },
            B: function(octave, bs) { 
                bs = bs || 0;
                return  note.allNotes()[(11 + bs) * 9 + octave];
            },

            cIndex: function() { return 0 * 9; },
            dIndex: function() { return 2 * 9; },
            eIndex: function() { return 4 * 9; },
            fIndex: function() { return 5 * 9; },
            gIndex: function() { return 7 * 9; },
            aIndex: function() { return 9 * 9; },
            bIndex: function() { return 11 * 9; },

            transposeOctave: function(startNote, octaves) {
                if ((startNote % 9 == 0 && octaves < 0) || ((startNote + 1) % 9) == 0 && octaves > 0)
                    return note.allNotes()[startNote];
                else
                    return note.allNotes()[startNote + octaves];
            },

            transposeSemiTone: function(startNote, semitone) {
                if (startNote / 9 == 0 && semitones < 0)
                    return note.allNotes()[startNote];
                if (startNote / 9 == 11 && semitones > 0)
                    return note.allNotes()[startNote];
                return note.allNotes()[startNote + (semitone * 9)];
            },
        }

        // Class for all 4x4 matrix functions
        var m4 = {
            identity: function() {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1,
                ];
            },

            inverse: function(m) {
                var m00 = m[0 * 4 + 0];
                var m01 = m[0 * 4 + 1];
                var m02 = m[0 * 4 + 2];
                var m03 = m[0 * 4 + 3];
                var m10 = m[1 * 4 + 0];
                var m11 = m[1 * 4 + 1];
                var m12 = m[1 * 4 + 2];
                var m13 = m[1 * 4 + 3];
                var m20 = m[2 * 4 + 0];
                var m21 = m[2 * 4 + 1];
                var m22 = m[2 * 4 + 2];
                var m23 = m[2 * 4 + 3];
                var m30 = m[3 * 4 + 0];
                var m31 = m[3 * 4 + 1];
                var m32 = m[3 * 4 + 2];
                var m33 = m[3 * 4 + 3];
                var tmp_0  = m22 * m33;
                var tmp_1  = m32 * m23;
                var tmp_2  = m12 * m33;
                var tmp_3  = m32 * m13;
                var tmp_4  = m12 * m23;
                var tmp_5  = m22 * m13;
                var tmp_6  = m02 * m33;
                var tmp_7  = m32 * m03;
                var tmp_8  = m02 * m23;
                var tmp_9  = m22 * m03;
                var tmp_10 = m02 * m13;
                var tmp_11 = m12 * m03;
                var tmp_12 = m20 * m31;
                var tmp_13 = m30 * m21;
                var tmp_14 = m10 * m31;
                var tmp_15 = m30 * m11;
                var tmp_16 = m10 * m21;
                var tmp_17 = m20 * m11;
                var tmp_18 = m00 * m31;
                var tmp_19 = m30 * m01;
                var tmp_20 = m00 * m21;
                var tmp_21 = m20 * m01;
                var tmp_22 = m00 * m11;
                var tmp_23 = m10 * m01;

                var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -
                    (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
                var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -
                    (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
                var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -
                    (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
                var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -
                    (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);

                var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);

                return [
                    d * t0,
                    d * t1,
                    d * t2,
                    d * t3,
                    d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -
                        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30)),
                    d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -
                        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30)),
                    d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -
                        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30)),
                    d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -
                        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20)),
                    d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -
                        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33)),
                    d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -
                        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33)),
                    d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -
                        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33)),
                    d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -
                        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23)),
                    d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -
                        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22)),
                    d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -
                        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02)),
                    d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -
                        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12)),
                    d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -
                        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02))
                ];
            },

            multiply: function(a, b) {
                var b00 = b[0 * 4 + 0];
                var b01 = b[0 * 4 + 1];
                var b02 = b[0 * 4 + 2];
                var b03 = b[0 * 4 + 3];
                var b10 = b[1 * 4 + 0];
                var b11 = b[1 * 4 + 1];
                var b12 = b[1 * 4 + 2];
                var b13 = b[1 * 4 + 3];
                var b20 = b[2 * 4 + 0];
                var b21 = b[2 * 4 + 1];
                var b22 = b[2 * 4 + 2];
                var b23 = b[2 * 4 + 3];
                var b30 = b[3 * 4 + 0];
                var b31 = b[3 * 4 + 1];
                var b32 = b[3 * 4 + 2];
                var b33 = b[3 * 4 + 3];
                var a00 = a[0 * 4 + 0];
                var a01 = a[0 * 4 + 1];
                var a02 = a[0 * 4 + 2];
                var a03 = a[0 * 4 + 3];
                var a10 = a[1 * 4 + 0];
                var a11 = a[1 * 4 + 1];
                var a12 = a[1 * 4 + 2];
                var a13 = a[1 * 4 + 3];
                var a20 = a[2 * 4 + 0];
                var a21 = a[2 * 4 + 1];
                var a22 = a[2 * 4 + 2];
                var a23 = a[2 * 4 + 3];
                var a30 = a[3 * 4 + 0];
                var a31 = a[3 * 4 + 1];
                var a32 = a[3 * 4 + 2];
                var a33 = a[3 * 4 + 3];

                return [
                    b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                    b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                    b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                    b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                    b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                    b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                    b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                    b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                    b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                    b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                    b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                    b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                    b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                    b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                    b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                    b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,
                ];
            },

            translation: function(tx, ty, tz) {
                return [
                     1,   0,  0,  0,
                     0,   1,  0,  0,
                     0,   0,  1,  0,
                     tx, ty, tz,  1,
                ];
            },
            
            xRotation: function(angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                return [
                    1,  0,  0,  0,
                    0,  c,  s,  0,
                    0, -s,  c,  0,
                    0,  0,  0,  1,
                ];
            },

            yRotation: function(angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                return [
                    c,  0, -s,  0,
                    0,  1,  0,  0,
                    s,  0,  c,  0,
                    0,  0,  0,  1,
                ];
            },

            zRotation: function(angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                return [
                    c,  s,  0,  0,
                   -s,  c,  0,  0,
                    0,  0,  1,  0,
                    0,  0,  0,  1,
                ];
            },
            
            scaling: function(sx, sy, sz) {
                return [
                    sx, 0,  0,  0,
                    0, sy,  0,  0,
                    0,  0, sz,  0,
                    0,  0,  0,  1,
                ];
            },

            perspective: function(fieldOfViewInRadians, aspect, near, far) {
                var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
                var rangeInv = 1.0 / (near - far);

                return [
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0,
                ];
            },

            // Note: this matrix flips the Y axis so that 0 is at the top
            orthographic: function(left, right, bottom, top, near, far) {
                return [
                    2 / (right - left), 0, 0, 0,
                    0, 2 / (top - bottom), 0, 0,
                    0, 0, 2 / (near - far), 0,
                    
                    (left + right) / (left - right),
                    (bottom + top) / (bottom - top),
                    (near + far) / (near - far),
                    1,
                ];
            },

            translate: function(m, tx, ty, tz) {
                return m4.multiply(m, m4.translation(tx, ty, tz));
            },

            xRotate: function(m, angleInRadians) {
                return m4.multiply(m, m4.xRotation(angleInRadians));
            },

            yRotate: function(m, angleInRadians) {
                return m4.multiply(m, m4.yRotation(angleInRadians));
            },

            zRotate: function(m, angleInRadians) {
                return m4.multiply(m, m4.zRotation(angleInRadians));
            },

            scale: function(m, sx, sy, sz) {
                return m4.multiply(m, m4.scaling(sx, sy, sz));
            },

            lookat: function(cameraPosition, target, up) {
                var zAxis = normalize(subtractVectors(cameraPosition, target));
                var xAxis = normalize(cross(up, zAxis));
                var yAxis = normalize(cross(zAxis, xAxis));

                return [
                    xAxis[0], xAxis[1], xAxis[2], 0,
                    yAxis[0], yAxis[1], yAxis[2], 0,
                    zAxis[0], zAxis[1], zAxis[2], 0,
                    cameraPosition[0],
                    cameraPosition[1],
                    cameraPosition[2],
                    1,
                ];
            },

            transformVector: function(matrix, point) {
                dst = new Float32Array(4);
                for (var i = 0; i < 4; ++i) {
                    dst[i] = 0.0;
                    for (var j = 0; j < 4; ++j) {
                        dst[i] += point[j] * matrix[j * 4 + i];
                    }
                }
                return dst;
            },

            transpose: function(m) {
                return [
                    m[0], m[4], m[8], m[12],
                    m[1], m[5], m[9], m[13],
                    m[2], m[6], m[10], m[14], 
                    m[3], m[7], m[11], m[15], 
                ];
            },
        }

        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0],
            ];
        }

        function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }

        function subtractVectors(a, b) {
            return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
        }

        function normalize(v) {
            var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            // Don't divide by zero
            if (length > 0.00001)
                return [v[0] / length, v[1] / length, v[2] / length];
            else
                return [0, 0, 0];
        }

        

        function rad2Deg(radians) {
            return radians * (180 / Math.PI);
        }

        function deg2Rad(degrees) {
            return degrees * (Math.PI / 180);
        }

        // Global variables
        var then = 0;
        var instrRotationRadians = 0.0;
        var spacingSpeed = 0.0;
        var fAngleRadians = 0.0;
        var cameraLookAtY = 0.0;
        var cameraLookAtX = 0.0;
        var isPlaying = true;
        var eqFrequency = note.F(4);
        var oscFrequency = note.F(3);
        var reverbAmount = 4.0;
        var camPosX = 0;
        var camPosY = 800;
    </script>
</body>
</html>
